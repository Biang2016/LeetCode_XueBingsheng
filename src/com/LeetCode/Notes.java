package com.LeetCode;

/**
 * Created by biang on 2017/12/4.
 */
public class Notes {

    //basic case:
    //null判定
    //dp问题一两个基本情况，或一行基本情况，或一行一列基本情况


    //判断两个区间是否重叠的简介代码
    //if(Math.max(s1, s2) < Math.min(e1,e2));


    //4   经典二分搜索难题，查找两个排序数组的中位数，通过不断缩小较小数组中的候选中位数的位置的范围，实现O（log（m+n））

    //二叉树遍历，分别用递归和非递归展开，非递归用stack做
    //144 二叉树先序遍历，stack，先压右再压左（中等）
    //94  二叉树中序遍历，stack（最简单），左边压完，输出中间，压右边
    //145 二叉树后序遍历，stack先压跟再压右再压左，若方位某节点时，其右节点未访问，将该节点重新压入栈（最难，需要反复练习）
    //94X 二叉树层序遍历，用队列做

    //21  排序链表合并，递归解法超级快
    //23  K个排序链表合并，将K个链表二分（使每次合并时长度不会过长），再逐渐合并，合并方法调用2链表合并
    //    解法2：使用优先队列，直接将各链表首元素扔入队列，然后出队依次链接

    //263，264 丑数DP问题，使用min函数找下一个值，再判断min等于哪一个，给哪个指针++（避免2*3=6的情况出现异常），判断3个数的最小值是哪个的时候用min完再匹配


    //11  装水问题，采用反证法证明，贪婪的方式不易想出，宜复习
    //42  装水问题，那边门槛低先装哪边，记录最高门槛值作为当前水平面，O(n)时间
    //53  最大子序列问题，可用DP线性解决

    //101  二叉树的对称性判断，递归法和迭代法（中序遍历）
    //123  在一堆出现3遍的数字中找到那个只出现1次的数，采用扩展的异或方法（三次异或正好暴露结果）。Inspired by 两次异或暴露只出现1次的数
    //260  在一堆出现2遍的数字中找到2个只出现1次的数，先找到这两个数的异或值，在按照这两个数的不同位将数组分为两个子数组，在子数组中分别找出只出现一个的数

    //731  日程安排重叠问题，可使用treemap进行优雅解决
    //739  找到后边最近的比该数大的数，用栈做，将下标塞入栈中而不是原数字（可以通过下标到原数组查询值的大小），然后用下标相减即可得到距离，根本不用记录距离
    //756  位操作解决"搭建字符金字塔可行性"问题，精彩范例；此外，将DFS中曾经尝试错误的case记录在hashset中，下次遇到时节省时间
    //761  Hard平衡二进制字符串，1的个数等于0的个数，且任何前缀中1的个数大于等于0的个数，可以转化为没有负值的小山，通过山的高度排序来解决问题
    //763  字符串分割为若干个互斥字符串（包含的字符全不相同），采用记住每个字符最后出现的位置的方法，遍历两遍即可解
    //764  在方阵中找到最大的十字形，返回十字形的阶  //DP算法，从左往右、从右往左、从上往下、从下往上分别记录一次当前最大连续长度，然后综合取小值
}
